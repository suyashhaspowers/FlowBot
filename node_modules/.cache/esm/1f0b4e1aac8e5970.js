let RTMClient,WebClient;_ac8‍.w("@slack/rtm-api",[["RTMClient",["RTMClient"],function(v){RTMClient=v}]]);_ac8‍.w("@slack/web-api",[["WebClient",["WebClient"],function(v){WebClient=v}]]);



require('dotenv').config();

const rtm = new RTMClient(process.env.TOKEN);
const web = new WebClient(process.env.TOKEN)
const moment = require('moment');
const chrono = require('chrono-node');

rtm.start()
    .catch(_ac8‍.g.console.error);

rtm.on("ready", async() => {
    console.log("bot started");
    sendMessageNow('U01A9Q7QJEP', 'TEST MESSAGES');
    getChatHistory('D01DBB0JB4Y');
});

rtm.on('slack_event', async (eventType, event) => {
    if (event && event.type === 'message' && 'bot_id' in event === false) {
        //console.log(event.text);
        //console.log(event);
        handleMessage(event);
    }
})

// Function that sends message right now
async function sendMessageNow(channel, message) {
    try {
        await web.chat.postMessage({
            channel: channel,
            text: message,
            as_user: true,
            username: "FlowBot"
        })
    }
    catch(e) {
        _ac8‍.g.console.error(e);
    }
}

// Function that sends message at posted time

async function sendMessageLater(channel, message, time) {
    try {
        await web.chat.scheduleMessage({
            channel: channel,
            text: message,
            post_at: time,
            as_user: true,
            username: "FlowBot"
        })
    }
    catch(e) {
        _ac8‍.g.console.error(e);
    }
}

async function getChatHistory(channel) {
    try {
        const history = await web.conversations.history({
            channel: channel,
        })
        //console.log(history.messages);
    }
    catch(e) {
        _ac8‍.g.console.error(e);
    }
}

function handleMessage(event) {
    var message;
    var send_date;
    var scheduled = false;
    if (event.text == '!start' || event.text == '!restart') {
        message = 'Hey! Who would you like to message?';
    }
    else if (event.text == '!help') {
        message = `Welcome to FlowBot! FlowBot allows you to schedule your messages such that you don't interrupt and break your co-worker's state of flow. To get started, type *!start* . If you want to restart, simply input *!restart* .`;
    }
    else if (event.text.includes("<@") && event.text.includes(">")) {
        message = `Enter the message you wanted to send them. Include them within triple quotations (""") to help me better read them
        
        ex. 
        """ Sample message """`;
    }
    else if (event.text.includes('"""')) {
        message = `How long from now would you like me to send this message?
        
            ex. 
                25 minutes`;
    }
    else if (false /* add logic for why this should be true */) {
        // Maybe add some formatting here where it mentions to who and at what time.
        message = "Thank you! Your message will be sent when requested.";
        scheduled = true;
    }

    else {
        // test to see if chrono is working
        scheduled = true;
        send_date = get_datetime_object('message', event);
        message = 'Your message will be sent!';
        // end of test
        //message = "Unknown command! To get help, simply input *!help* or to start, input *!start* .'";
    }
    sendMessageNow(event.channel, message);

    if (scheduled) {
        var ts = Math.round(send_date.getTime() / 1000);
        // Will not be event.channel. We will have to go through the chatHistory and get the person and message they wanted to send.
        sendMessageLater(event.channel, message, ts);
    }
}

function get_datetime_object(message, event) {
    const date = new Date();
    _ac8‍.g.console.log(date);
    _ac8‍.g.console.log(event.text);
    const get_date = chrono.casual.parseDate(event.text);
    //console.log(get_date);
    return get_date;
}